leammaSummary
每个合数都可以写成几个质数相乘的形式，其中每个质数都是这个合数的因数，叫做这个合数的分解质因数。 分解质因数只针对合数。
定义
把一个合数分解成若干个质因数的乘积的形式，即求质因数的过程叫做分解质因数。
分解质因数只针对合数。（分解质因数也称分解素因数）求一个数分解质因数，要从最小的质数除起，一直除到结果为质数为止。分解质因数的算式叫短除法，和除法的性质差不多，还可以用来求多个个数的公因式。
定理
不存在最大质数的证明：（使用反证法）
假设存在最大的质数为N，则所有的质数序列为：N1，N2，N3……N
设M=（N1×N2×N3×N4×……N）+1，
可以证明M不能被任何质数整除，得出M也是一个质数。
而M>N，与假设矛盾，故可证明不存在最大的质数。
第二种因数分解的方法：
1975年，John M. Pollard提出。该算法时间复杂度为O( )。详见参考资料[1] 。
编程分解
program dsq;　　var　　n,i:longint;　　begin　　readln(n);　　write(n,'=1');　　i:=2;　　while i<n do begin　　while n mod i = 0 do begin　　write('*',i);　　n:=n div i;　　end;　　inc(i);　　end;　　end.
另一种实现
#include <stdio.h>
Integer m,b,c := 0,j := 0;
Integer a[10]; //存放质因数
Integer fjzys(Integer k)
begin
Integer i := 2;
while (k> := i) do //判断k是否合格
begin
if (k mod i=0) then //判断k是否整除当前因数
begin
a[j] := i; //存入因数
k/ := i; //余数
i := 2; //令i重新等于2
j++; //计数值
end
else
begin
i++; //不能整除则当前因数为非质因数
end;
end;
(* C2PAS: Exit *) Result := 0;
end;
(* 用for实现上面的函数
int fjzys(int k)
{
int i=2;
for ( ; i<=k ; i++ ) //当因数i<=k时，实现该循环，每次循环因数i自加1
for ( ; k%i==0 ; j++ ) //当k整除当前因数，实现该循环，每次循环下标j自加1
{
k/=i; //使k=k/i
a[j]=i; //存入因数
}
return 0;
}
解决上面的函数，无法输出，多个相同的质因数，如90=2*3*3*5，只能输出一个3.
*)
void main()
begin
printf('请输入一个整数'#10'k=');
scanf('%d', (* C2PAS: RefOrBit? *)&m);
fjzys(m);
for(b := 0;b<(j-1);b++) //*比质因数少一个
begin
printf('%d',a[b]);
printf('*');
end;
printf('%d'#10'',a[j-1]); //输出最后一个质因数
end;
实现一，此代码因为用了long long int，为C99标准，故不可在VC6.0上运行。　　
实现二
可直接在VC6.0运行。
(defun is-prime-number (number)　　(let ((num number))　　(do ((index 2 （1+ index)))　　((>= index num) t)　　(if (= 0 (mod num index))　　(return-from is-prime-number nil)))))　　(defun decomposition-quality-factor (number)　　(let ((num number) (prime-list (make-array 10 :fill-pointer 0 :adjustable t)))　　(if (is-prime-number num)　　(progn　　(format t "~a~%" num)　　(return-from decomposition-quality-factor nil)))　　(do ((index 2 （1+ index)))　　((>= index num) nil)　　(if (is-prime-number index)　　(push index prime-list)))　　(dolist (value prime-list)　　(let ((test-flag nil))　　(do ()　　(test-flag nil)　　(if (= 0 (mod num value))　　(progn　　(format t "~a~%" value)　　(setf num (/ num value))　　(if (is-prime-number num)　　(progn　　(format t "~a~%" num)　　(return-from decomposition-quality-factor nil))))　　(setf test-flag t)))))))
#!/usr/bin/bash
read input
factor "$input"
